{
  "name": "localCIDER",
  "tagline": "localCIDER lets you compute sequence parameters for disordered proteins",
  "body": "# localCIDER\r\n\r\n`v 0.1.9 - October 2016`\r\n\r\n\r\n# Introduction\r\n\r\n**CIDER** [Classification of Intrinsically Disordered Ensemble Regions](http://pappulab.wustl.edu/CIDER) is a web-server for calculating various properties of a disordered sequence. CIDER's calculations are carried out by a backend app, called localCIDER.\r\n\r\n**CIDER** is useful if you want to quickly calculate some parameter on the fly. HOWEVER, for doing a large number of sequences, we recommend you instead use **localCIDER** and carry out the computation locally.\r\n\r\n## localCIDER vs. CIDER?\r\n**localCIDER** lets us provide an implicit distributed computing model to all of CIDER's calculations. Think of it this way - if 100 people have 100 sequences, we (the Pappu lab) have the burden of 10,000 calculations to perform. If everyone submitted these sequences at once, the website would slow for everyone, and maybe crash. This is a lot of work for us, and very annoying for you, the user. HOWEVER, by using **localCIDER** you can take advantage of\r\n\r\n* Your own local infrastructure\r\n* The ability to programmatically create analysis pipelines\r\n* The fact you can operate independently of the CIDER web-server\r\n\r\nMoreover, if there's a type of analysis you use frequently and you think other users would appreciate, we'd be happy to build this in to **localCIDER**. Adding new functionality is typically much more involved for a web-app.\r\n\r\n# Installation\r\n\r\n## Introduction\r\n**localCIDER** version 0.1.9 was submitted to PyPI (the Python Package Index) in October 2016. This should be considered a stable release, however, if you encounter any issues/bugs it would be greatly appreciated if you could report any issues to alex.holehouse@wustl.edu. \r\n\r\n## New Features\r\nIn 0.1.9 we have added a number of new features, as detailed below:\r\n\r\n* Local compositional analysis has been added to help identify local regions which are enriched in a particular type of amino acid. Proteins are complex heteropolymers, so plotting the local density of each amino acid with a sliding becomes impossible to interpret, as we just generate a series of jagged lines. To overcome this challenge we take a dual approach: firstly, amino acids are group by physiochemical properties. Secondly, we then fit the noisy data to a univariate spline to give a smoothed description of the local density along the sequence. Combined, this allows us to generate easy-to-read plots that illustrate the local density of residues at any given location along the sequence\r\n\r\n* The Omega patterning parameter (previously kappa_proline) is re-defined as per the manuscript by Martin & Holehouse *et al.*\r\n\r\n* A generalized patterning parameter for considering 2 or 3 letter alphabets is released, allowing researchers to, generally, ask questions about sequence patterning\r\n\r\n* The figure generation code has been further optimised, as has code documentation\r\n\r\nIf there are sequence feautures you would like to see added to localCIDER please don't hesitate to get in touch - we're always looking for new features to add and to further grow localCIDER as a general purpose protein analysis framework.\r\n\r\n## Installing on OSX or linux\r\nWe recommend installing using `pip`. `pip` is a command line interface for downloading and installing packages from the Python package index (PyPI). If you don't yet have pip installed [see the documentation here](http://pip.readthedocs.org/en/latest/installing.html).\r\n\r\nWe also recommend `virtualenv` although this is not at all required, it's just generally a good route to go if you use Python! For more information on `virtualenv` check out [this link](https://virtualenv.pypa.io/en/latest/)\r\n\r\nOnce `pip` is installed, **localCIDER** can be installed by running;\r\n\r\n    [sudo] pip install localcider \r\n\r\nVery simple! **localCIDER** depends on both `numpy` and `matplotlib`, both of which will be installed via `pip` if you haven't already installed them.\r\n\r\nIf you encounter issues installing please let me know. That said, any issues *should* be due to problems with Numpy or `matplotlib` and not **localCIDER**, so investigate the documentation associated with installing those packages first.\r\n\r\n## Python 2 and Python 3\r\nAs of version 0.1.8 localCIDER is supported under both Python 2.x and 3.x. localCIDER has been extensively tested and used with Python 2.7.x, and we recommend this version of Python.\r\n\r\n### Known installation issues\r\n\r\n#### OpenSuse\r\n`pip` will not install system level dependencies, so you may need to install additional packages to get matplotlib working with vanilla `OpenSuse`. Specifically\r\n\r\n    [sudo] zypper install freetype2-devel\r\n    [sudo] zypper install gcc-c++\r\n    [sudo] zypper install libpng16-devel\r\n    [sudo] zypper install python-numpy-devel\r\n    \r\nOf course, one or more of these may already be installed, so your best bet is to try installing **localcider**, and if it fails check these guys are installed by using\r\n\r\n    zypper search <package-name> # an 'i' next to the package indicates it's installed\r\n\r\nAn alternative issue may be that installing `python-numpy-devel` (which is required by pip to build `matplotlib`) requires numpy-1.7 and you have numpy-1.8. In *this* case we recommend using\r\n\r\n    [sudo] zypper install python-matplotlib-tk\r\n    \r\nTo install `matplotlib` (NOTE the `-tk` at the end!)\r\n\r\nGetting Python packaging and OpenSuse to work together can be a pain, so there are likely alternative solutions to those presented here.\r\n\r\n#### Ubuntu\r\nThe issues for OpenSuse are also true for Ubuntu - specifically `Ubuntu` seems to need the `python-dev` package to install `numpy`, and the `libfreetype6-dev` package for to get Freetype working in `matplotlib`\r\n\r\n    [sudo] apt-get install python-dev\r\n    [sudo] apt-get install libfreetype6-dev \r\n\r\n\r\n### Upgrading via pip\r\nlocalCIDER does not automatically update, but can be updated using pip. To see the historic update schedule see the end of this file.\r\n\r\n`pip` allows you to upgrade packages to the latest version using\r\n\r\n    [sudo] pip install --upgrade localcider\r\n    \r\nHowever, this command will upgrade all the dependencies as well, which may not be a desirable behaviour. To upgrade *just* **localCIDER** use\r\n\r\n    [sudo] pip install -U --no-deps lolcacider \r\n\r\nAlternativly, you can update by uninstalling and re-installing `localcider` using\r\n\r\n    pip uninstall localcider\r\n    pip install localcider \r\n    \r\n    \r\n## Installation on Windows\r\n   \r\nTested on Windows 7 64 bit\r\n\r\n1) Download and install Anaconda package (http://continuum.io/downloads)\r\n\r\n2) Download `get-pip.py` (https://bootstrap.pypa.io/get-pip.py)\r\n\r\n3) Open `cmd.exe` from start menu (this is windows command prompt)\r\n\r\n4) Change directory to that containing `get-pip.py` (EX: `cd  \"D:\\downloads\" ` )\r\n\r\n5) In `cmd.exe` run `python get-pip.py`\r\n\r\n6) In `cmd.exe` run `pip install localcider`\r\n\r\n7) Open IPython Notebook from the windows start menu (installed with Anaconda package, other editors can be used i.e. PyCharm)\r\n\r\n8) Write code to use localCIDER package\r\n \r\n \r\n# Using localCIDER\r\nOnce you have localCIDER installed, fire up Python and `import` the localcider package;\r\n\r\n    import localcider\r\n    \r\nYou'll be greeted with a message detailing the current version.\r\n\r\nThere are two main localcider modules right now;\r\n\r\n* `sequenceParameters` which lets you calculate many different parameters, as well as show or save plots relating to a specific sequence - ***this is the main module of interest***\r\n* `plots` which lets you plot certain parameters independent of sequenceParameters\r\n\r\n\r\n#### Quick-start - calculate kappa of my sequence and plot it on the Das-Pappu diagram of states \r\n\r\nThe following code will print the kappa value of your sequence to the terminal prompt, and then plot your sequence on a Das-Pappu phase plot, saving it in the current directory as `my_snazzy_plot.png`\r\n\r\n    # import the relevant code\r\n    from localcider.sequenceParameters import SequenceParameters\r\n    \r\n    # create a SequenceParameters object with your amino acid sequence\r\n    SeqOb = SequenceParameters(\"DAEFRHDSGYEVHHQKLVFFAEDVGSNKGAIIGLMVGGVV\")\r\n    \r\n    # carry out analysis\r\n    SeqOb.get_kappa() \r\n    SeqOb.save_phaseDiagramPlot('my_snazzy_plot')\r\n    \r\n    # For publications we recommend using vector graphics and saving plots as PDF files \r\n    SeqOb.save_phaseDiagramPlot('my_snazzy_plot', saveFormat='pdf'))\r\n    \r\n    \r\n#### Interactive help\r\n\r\n**localCIDER** contains highly complete interactive help - for any object or function simply type `help(<item>)` for a complete description. For example;\r\n\r\n    # import the relevant code\r\n    from localcider.sequenceParameters import SequenceParameters\r\n    \r\n    # create a SequenceParameters object with your amino acid sequence\r\n    SeqOb = SequenceParameters(\"MY AMINO ACID SEQUENCE\")\r\n    \r\n    help(SeqOb)\r\n    \r\n    help(SeqOb.get_kappa())\r\n\r\n\r\n# General sequence analysis with SequenceParameters\r\n\r\nThe approach we recommend for accessing SequenceParameters objects is to use the following Python code;\r\n\r\n\r\n    from localcider.sequenceParameters import SequenceParameters\r\n    \r\n    \r\nBy opening your code with this line you now have direct access to the `SequenceParameters` class, which takes either a string of an amino acid sequence or the filename of a file containing an amino acid sequence, which is then read and parsed. As an example;\r\n\r\n\r\n    # as before we import the SequenceParameters class directly\r\n    from localcider.sequenceParameters import SequenceParameters\r\n\t\r\n\t# the sequence below is the first 30 residues from alpha-synuclein\r\n\tSeqOb = SequenceParameters(\"MDVFMKGLSKAKEGVVAAAEKTKQGVAEAA\")     \r\n    \r\nOr alternatively\r\n    \r\n    # as before we import the SequenceParameters class directly\r\n    from localcider.sequenceParameters import SequenceParameters\r\n\t\r\n\t# the sequence below is the first 30 residues from alpha-synuclein\r\n\tSeqOb = SequenceParameters(sequenceFile=\"syn.fasta\")\r\n\t\r\n\t\r\n\r\nBoth these code snippets create a `SequenceParameters` object - here that object is called `SeqOb`, but obviously this variable could be named anything. We can run a huge range of analysis routines on this object. The complete function list is shown below for reference.\r\n\r\nMany of these functions don't take arguments. Optional arguments are prefixed with a question mark (?). For each function we use the `seqOb.<function>` syntax - e.g.\r\n\r\n    seqOb.get_FCR()\r\n\r\n\r\n### Single value sequence analysis functions\r\nThe functions below perform analysis which ge\r\n\r\nFunction name | Operation \r\n:---: | :---: \r\n`get_length()`  | Get the sequence length\r\n`get_FCR()`  | Get the fraction of charged residues in the sequence [4]\r\n`get_NCPR()` | Get the net charge per residue of the sequence [5]\r\n`get_countNeg()` | Get the number of negatively charged residues in the sequence (D/E)\r\n`get_countPos()` | Get the number of positively charged residues in the sequence (R/K)\r\n`get_countNeut()` | Get the number of neutral amino acids\r\n`get_fraction_negative()` | Get the fraction of residues which are negatively charged (F-)\r\n`get_fraction_positive()` | Get the fraction of residues which are positively charged (F+)\r\n`get_fraction_expanding()` | Get the fraction of residues which are predicted to contribute to chain expansion (E/D/R/K/P)\r\n`get_amino_acid_fractions()` | Get a dictionary of the fractions of each amino acid in the sequence\r\n`get_fraction_disorder_promoting()` | Get the fraction of residues predicted to be 'disorder promoting' [1]. Note this is NOT a disorder prediction!\r\n`get_kappa()` | Get the sequence's kappa value [2]\r\n`get_kappa_Omega()` | Get the sequence's Omega value. Omega defines the patterning between charged/proline residues and all other residues, and is described further in the forthcoming paper by Martin and Holehouse (submitted Sept. 2016).\r\n`get_kappa_Omega_sequence()` | Returns the reduced-alphabet sequence used to calculate the Omega parameter, where by R/K/D/E/P residues are defined as 'X' and all other residues are 'O'. This provides a clear visual description of the charge/proline patterning.\r\n`get_mean_net_charge()` | Get the absolute mean net charge of your sequence\r\n`get_phase_plot_region()` | Get the region on the Das-Pappu diagram of states where your sequence falls [2]\r\n`get_mean_hydropathy()` | Get the mean hydropathy as calculated from a skewed Kyte-Doolittle hydrophobicity scale* [3]\r\n`get_uversky_hydropathy()` | Get the mean hydropathy as calculated from a normalized Kyte-Doolittle hydrophobicity scale\\*\\* [3,4]\r\n`get_PPII_propensity()` | Get the overall sequence's PPII propensity as defined by Hilser et al [6] using the values reported in table 1 from [7]\r\n`get_delta()` <br> | Returns the delta value of the sequence, as defined when calculating kapp [2] \r\n`get_deltaMax()` <br> | Returns the maximum possible delta value (delta-max) for a sequence of this composition\r\n\r\n\r\n\r\n\\* The skewed hydrophobicity scale shifts the normal KD scale such that the lowest value is 0 (instead of -4.5) and the highest value is 9 (instead of 4.5)\r\n\r\n\\** The normalized Kyte-Doolittle scale converts all values on the scale to fall between 0 and 1\r\n\r\n\r\n### Vectorial sequence analysis functions\r\nThe following functions generate a vector of values which describes some property associated with the sequence as a function of sequence position.\r\n\r\nFunction name | Operation \r\n:---: | :---: \r\n`get_linear_FCR(blobLen=5)`  | Returns a 2D numpy vector of the fraction of charged residues (FCR) as defined by a sliding window. The first dimension of the 2D vector contains the local FCR values and the second contains the associated residue index values along the sequence. the `blobLen` keyword defines the window size used to calculate the sequence-local FCR. A stepsize of 1 is always used.\r\n`get_linear_NCPR(blobLen=5)`  | Returns a 2D numpy vector of the net charge per residue (NCPR) as defined by a sliding window. The first dimension of the 2D vector contains the local NCPR values and the second contains the associated residue index values along the sequence. The `blobLen` keyword defines the window size used to calculate the sequence-local NCPR. A stepsize of 1 is always used.\r\n`get_linear_hydropathy(blobLen=5)`  | Returns a 2D numpy vector of the local hydropathy as defined by a sliding window using the Kyte-Doolite hydropathy scale[3]. The first dimension of the 2D vector contains the local hydropathy score and the second contains the associated residue index values along the sequence. The `blobLen` keyword defines the window size used to calculate the sequence-local hydropathy. A stepsize of 1 is always used.\r\n`get_linear_complexity(complexityType='WF', alphabetSize=20, userAlphabet={}, windowSize=10, stepSize=1, wordSize=3)` | Returns the linear sequence complexity as defined by complexityType. Optionally, the sequence complexity of a reduced complexity alphabet can be returned, where that reduced alphabet is defined by either the alphabetSize (which takes advantage of 11 pre-defined simplified alphabets) or via a custom userAlphabet dictionary. <br><br>The `complexityType` Defines the complexity measure being employed. Three different complexity measures are provided by localCIDER, where the measure being used is passed via a string with one of 'WF', 'LC', or 'LZW'. WF is Wooton-Federhen complexity [8], which reports on the sequence's local Shannon entropy, and is the complexity measure used in the SEG algorithm. LC is Linguistic complexity [9], which reports on the number of distinct subsequences over the maximum number of different subsequences given the alphabet size and the word size. Finally, LZW is Lempel-Ziv-Welch [10] complexity, and effectivly asks how efficienctly the sequence can undergo lossless compression using unique subsequences. <br><br>The `alphabetSize` defines the size of the alphabet being used, where pre-defined alphabets are then used based on the specific size. Those pre-defined alphabets are defined below this table for clarity. By default an `alphabetSize` of 20 is used (i.e. no reduction in amino acid complexity). 'userAlphabet' Allows the user to define their own reduced alphabet. The format here is a dictionary where each key-value pair is amino-acid to X. This means you need a dictionary of length 20 where each amino acid is mapped to another amino acid. This is somewhat of tedious, but it helps avoid user-error where specific amino acids are missed. (default=None). <br><br>The `blobLen` is the sliding window size over which complexity is calculated (default=10). The `stepSize` is the size of steps taken as we define a new sliding window. Finally, the `wordSize` keyword is only relevant for the linguistic complexity (LC), ignored for other types, and defines the size of word for the algorithm. Default is 3. We recommend further reading of the associated literature to better understand these complexity measures. \r\n`get_linear_sequence_composition(blobLen=5, grps=[])`  | Returns an X by n matrix, where n is the number of amino acids in the sequence and X is the number of distinct groups of amino acids provided. This functions allows the local amino acid composition to be explored using a sliding window that computes the local density of one or more groups of amino acids along the sequence. The `blobLen` keyword defines the window size used to calculate the local sequence composition, and a stepsise of 1 is always used. The `grps` variable defines a list of lists, where each sub-list has elements that are amino acids. If no groups are provided a default grouping of amino acids by their physiochemical properties are used, i.e. `grps = [['E','D'], ['R','K'], ['R','K','E','D'], ['Q','N','S','T','G','H', 'C'], ['A','L','M','I','V'], ['F','Y','W'], ['P']]`, where groupsings are negativly charged, positivly chagred, charged, polar, aliphatic, aromatic, proline.\r\n\r\n#### Reduced alphabets\r\nPredefined alphabets shown below - all except eleven are based on alphabets defined in the reference below [11].\r\n\r\n    two      - [(LVIMCAGSTPFYW), (EDNQKRH)]\r\n    three    - [(LVIMCAGSTP), (FYW), (EDNQKRH)]\r\n    four     - [(LVIMC), (AGSTP), (FYW), (EDNQKRH)]\r\n    five     - [(LVIMC), (ASGTP), (FYW), (EDNQ), (KRH)]\r\n    six      - [(LVIM), (ASGT), (PHC), (FYW), (EDNQ), (KR)]\r\n    eight    - [(LVIMC), (AG), (ST), (P), (FYW), (EDNQ), (KR), (H)]\r\n    ten      - [(LVIM), (C), (A), (G), (ST), (P), (FYW), (EDNQ), (KR), (H)]\r\n    eleven   - [(LVIM), (C), (A), (G), (ST), (P), (FYW), (ED), (NQ), (KR), (H)]\r\n    twelve   - [(LVIM), (C), (A), (G), (ST), (P), (FY), (W), (EQ), (DN), (KR), (H)]\r\n    fifteen  - [(LVIM), (C), (A), (G), (S), (T), (P), (FY), (W), (E), (Q), (D), (N), (KR), (H)]\r\n    eighteen - [(LM), (VI), (C), (A), (G), (S), (T), (P), (F), (Y), (W), (E), (D), (N), (Q), (K), (R), (H)]\r\n    twenty   - all twenty!\r\n\r\n\r\n\r\n### Phosphorylation functions\r\nThe following functions augment your sequence to consider the impact of phosphorylation on the electrostatic properties. Note this makes the highly simplifying assumption that the phosphorylation of a Ser/Thr/Tyr residue simply adds a negative charge to your protein chain. In reality, many other properties of the chain are impacted by phosphorylation than simply the linear charge patterning.\r\n\r\nFunction name | Operation \r\n:---: | :---: \r\n`get_all_phosphorylatable_sites()` | Get a list of the positions of all Ser/Thr/Tyr residues. Note this function DOES NOT make any inference about accessibility or binding/recognition motifs, it's literally just a list of sites which canonically are able to be phosphorylated.\r\n`set_phosphosites(list_of_positions)` | Sets a residues which may be phosphorylatable (must be T/Y/S). Note this can be called multiple times, and will only set sites which are T/Y/S)\r\n`get_phosphosites()` | Get the list of sites currently designated as phosphosites by set_phosphosites\r\n`clear_phosphosites()` | Clears any previously defined phosphosites\r\n`get_kappa_after_phosphorylation()` | Get the kappa value assuming full phosphorylation (with H<sub>2</sub>PO<sub>4</sub><sup>-1</sup>).\r\n`get_phosphosequence()` | Returns the fully phosphorylated sequence, with \"phosphorylated residues\" replaced with glutamate (E)\r\n`get_full_phosphostatus_kappa_distribution()`|  For each possible phospho-permutant, given the available phosphosites, calculate the kappa, fraction positive, fraction negative, FCR, NCPR, mean hydropathy and the phosphostatus. Phosphostatus is itself a tuple, where each position defines the phosphorylation status of each consecutive phosphosite in the sequence; 0 indicates unphosphorylated and 1 indicates phosphorylated. <br> <br> The function call returns a list of tuples, where each tuple contains the information described for each unique phospho-permutant. The assumption currently being made is that phosphorylation introduces a -1 charge only. While this may not be fully accurate, it provides a good and simple first approximation for the effect of phosphorylation.  Also note that as the number of phosphosites increases the number of calculations here scales as n^2. Be warned!\r\n\r\n\r\n### Miscellaneous functions\r\nThe functions below represent a variety of miscellaneous functions.\r\n\r\nFunction name | Operation \r\n:---: | :---: \r\n`get_HTMLColorString()` <br> | Returns a fully formated HTML string which can be used to represent your sequence. The coloring used has a default, but can be defined using the `set_HTMLColorResiduePalette` function\r\n`set_HTMLColorResiduePalette(colorDictionary)` <br> | Allows you to custom define a colour pallete. The colorDictionary must be a dictionary object that maps each of the 20 amino acids to a color. Currently 17 possible colors can be assigned to the 20 amino acids. These are;<br> aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, orange, purple, red, silver, teal, white, and yellow. This set of 17 colors represents the HTML browser compatible set of colors.\r\n\r\n### Plotting functions (on-screen 'show' functions)\r\nThe following functions let you plot parameters from your sequence and display the results immediately on screen.\r\n\r\nFunction name | Operation \r\n:---: | :---: \r\n`show_phaseDiagramPlot(label=\"\", title='Diagram of states', legendOn=True, xLim=1, yLim=1, fontSize=10, getFig=False)`| Renders a `matplotlib` Das-Pappu diagram of states plot with your sequence on the diagram<sup>[2]</sup>. If a `label` is provided this is a string which annotates your sequence on the plot. If a `title` is provided this sets the plot title. `legendOn` defines if the region labels are included as a legend. `xLim` and `yLim` define the max values for the X and Y axes. `fontSize` defines the size of the label font. `getFig` defines if a matplotlib object is returned instead of being rendered on screen. \r\n`show_uverskyDiagramPlot(label=\"\", title='Uversky Plot', legendOn=True, xLim=1, yLim=1, fontSize=10, getFig=False)`| Renders a `matplotlib` Uversky plot with your sequence on the diagram<sup>[4]</sup>. `label` can be a string which labels your sequence on the plot. If a `title` is provided this sets the plot title. `legendOn` defines if the regions labels are included as a legend. `xLim` and `yLim` define the max values for the X and Y axes. `fontSize` defines the size of the label font. `getFig` defines if a matplotlib object is returned instead of being rendered.\r\n`show_linearHydropathy(blobLen=5, getFig=False)`| Renders a `matplotlib` plot of the moving average hydropathy along the sequence, where the hydropathy is calculated in overlapping windows of size `blobLen`. Typically a blob length of 5-7 is used. `getFig` defines if a matplotlib object is returned instead of being rendered.\r\n`show_linearNCPR(blobLen=5, getFig=False)` | Renders a `matplotlib` plot of the moving average net charge per residue (NCPR) along the sequence, where the NCPR is calculated in overlapping windows of size `blobLen`. Typically a blob length of 5-7 is used. `getFig` defines if a matplotlib object is returned instead of being rendered.\r\n`show_linearFCR(blobLen=5, getFig=False)` | Renders a `matplotlib` plot of the moving average fraction of charged residues (FCR) along the sequence, where the FCR is calculated in overlapping windows of size `blobLen`. Typically a blob length of 5-7 is used. `getFig` defines if a matplotlib object is returned instead of being rendered.\r\n`show_linearSigma(blobLen=5, getFig=False)` | Renders a `matplotlib` plot of the moving average sigma parameter along the sequence, where sigma is calculated in overlapping windows of size `blobLen`. Typically a blob length of 5-7 is used. Recall that sigma is calculated as the NCPR<sup>2</sup> / FCR. `getFig` defines if a matplotlib object is returned instead of being rendered.\r\n`show_linearComplexity(complexityType='WF', alphabetSize=20, userAlphabet={}, windowSize=10, stepSize=1, wordSize=3, getFig=False)` | Renders a `matplotlib` plot of the linear sequence complexity. For a discussion of the various options see the `get_linear_complexity` description under the SequenceParameters functions table. `getFig` defines if a matplotlib object is returned instead of being rendered.\r\n\r\n\r\n### Plotting functions (file-creating 'save' functions)\r\nThe following functions let you plot parameters from your sequence and save those plots to file for future use.\r\n\r\nFunction name | Operation \r\n:---: | :---: \r\n`save_phaseDiagramPlot(filename, label='', title='Diagram of states', legendOn=True, xLim=1, yLim=1, fontSize=10, saveFormat='png')` | Generates a `matplotlib` Das-Pappu diagram of states plot which is then saved to disk. `filename` is required and defines the file to be saved. Adding extensions is recommended but not required. All options are the same as in `show_phaseDiagramPlot`, with the addition of the `saveFormat` keyword, which defines the output format - this parameter is passed to matplotlibs savefig command which supports the following filetypes: emf, eps, pdf, png, ps, raw, rgba, svg, svgz. (DEFAULT = png) \r\n`save_uverskyPlot(filename, label='', title='Uversky plot', legendOn=True, xLim=1, yLim=1, fontSize=10, saveFormat='png')` | Generates a `matplotlib` Uversky plot with your sequence on the diagram<sup>[4]</sup> which is then saved to disk. `filename` is required and defines the file to be saved. Adding extensions is recommended but not required. All options are the same as in `show_uverskyPlot`, with the addition of the `saveFormat` keyword, which defines the output format - this parameter is passed to matplotlibs savefig command which supports the following filetypes: emf, eps, pdf, png, ps, raw, rgba, svg, svgz. (DEFAULT = png) \r\n`save_linearHydropathy(filename, blobLen=5, saveFormat='png')` | Renders a `matplotlib` plot of the moving average hydropathy along the sequence, where the hydropathy is calculated in overlapping windows of size `blobLen`. Typically 5-7 is used. The plot is saved in the `filename` location. Adding extensions is recommended but not required. The `saveFormat` keyword defines the output format - this parameter is passed to matplotlibs savefig command which supports the following filetypes: emf, eps, pdf, png, ps, raw, rgba, svg, svgz.\r\n`save_linearNCPR(filename, blobLen=5, saveFormat='png')`| Renders a `matplotlib` plot of the moving average net charge per residue (NCPR) along the sequence, where the NCPR is calculated in overlapping windows of size `blobLen`. Typically 5-7 is used. The plot is saved in the `filename` location. Adding extensions is recommended but not required. The `saveFormat` keyword defines the output format - this parameter is passed to matplotlibs savefig command which supports the following filetypes: emf, eps, pdf, png, ps, raw, rgba, svg, svgz.\r\n`save_linearFCR(filename, blobLen=5, saveFormat='png')`| Renders a `matplotlib` plot of the moving average fraction of charged residues (FCR) along the sequence, where the FCR is calculated in overlapping windows of size `blobLen`. Typically 5-7 is used. The plot is saved in the `filename` location. Adding extensions is recommended but not required. The `saveFormat` keyword defines the output format - this parameter is passed to matplotlibs savefig command which supports the following filetypes: emf, eps, pdf, png, ps, raw, rgba, svg, svgz.\r\n`save_linearSigma(filename, blobLen=5, saveFormat='png')`  | Renders a `matplotlib` plot of the moving sigma value, where sigma defines the local charge assymetry and is used in the calculation of kappa. Sigma is calculated over blobs of `blobLen` size, typically with blobs of 5-7 residues. The plot is saved in the `filename` location. Adding extensions is recommended but not required. The `saveFormat` keyword defines the output format - this parameter is passed to matplotlibs savefig command which supports the following filetypes: emf, eps, pdf, png, ps, raw, rgba, svg, svgz.\r\n`save_linearComplexity(filename, complexityType='WF', alphabetSize=20, userAlphabet={}, windowSize=10, stepSize=1, wordSize=3, saveFormat='png')` | Renders a `matplotlib` plot of the linear sequence complexity. For a discussion of the various options see the `get_linear_complexity` description under the SequenceParameters functions table. The plot is saved in the `filename` location. Adding extensions is recommended but not required. The `saveFormat` keyword defines the output format - this parameter is passed to matplotlibs savefig command which supports the following filetypes: emf, eps, pdf, png, ps, raw, rgba, svg, svgz.\r\n`save_linearCoposition(filename, blobLen=5, saveFormat='png', title='', plot_data=False))` | Renders a `matplotlib` plot of the local, vectorial amino acid composition. In version 0.1.9 the only grouping is the standard physiochemical grouping of amino acids, but in future versions we plan to add customizable groups to the plotting functions (customizable groups are available in the equivalent analysis function `get_linear_sequence_composition`). The local density is initially calculated and the fit to a univariate spline to remove noise and make the local sequence features more easily identifiable. If the `plot_data` variable is set to true the raw data is plotted alongside this spline fit, to ensure the fitting procedure is capturing the relevant sequence features. The plot is saved in the `filename` location. Adding extensions is recommended but not required. The `saveFormat` keyword defines the output format - this parameter is passed to matplotlibs `savefig` command which supports the following filetypes: emf, eps, pdf, png, ps, raw, rgba, svg, svgz.\r\n\r\n\r\n\r\n# Plotting with the plots module\r\n\r\nThe `plots` module lets you generate or save plots without explicitly invoking sequenceParameters objects. Such plots can either be generated using the raw values, or by passing in sequenceParameters objects.\r\n\r\nUnlike the `SequenceParameters`, `plots` is a collection of functions, and does not allow for the creation of `Plots` objects.\r\n\r\nIn the following discussion a **single** plot contains information from just one sequence, whereas a **multiple** plot contains sequence information from many sequences\r\n\r\n### Using `Plots` functions\r\n\r\nThere are two modes with which you can use plots functions;\r\n\r\n#### Passing raw parameters to be plotted (single and multiple plots)\r\nThis may be convenient if you're plotting previously calculated values, or plotting a theoretical distribution here. Either individual values or lists of values can be passed.\r\n\r\n### Passing SequenceParameters objects (multiple plots only)\r\nIf you're analyzing a set of SequenceParameters objects you may wish to place them on the same plot. Note we do not offer this functionality for single sequences, because you can always plot a single sequence using the associated `SequenceParameters` function (e.g. `.show_uverskyPlot()` or `.save_phaseDiagramPlot()`).\r\n\r\n\r\nFunction name | Input Arguments | Discussion\r\n:---: | :---: | :---:\r\n`show_single_phasePlot(fp, fn, label='', title='Diagram of states', legendOn=True, xLim=1, yLim=1, fontSize=10, getFig=False)` | `fp` is the fraction of positive residues in a sequence, `fn` is the fraction of negative residues in a sequence. `label`, if included, should be a string with which the sequence on the plot is labelled. `title`, if provided, sets the plot title. `legendOn` defines if the 5-region legend for the phase diagram plot is included. `xLim` and `yLim` define the max values for the X and Y axes. `fontSize` defines the size of the label font. `getFig` defines if a matplotlib object is returned instead of being rendered.   | No programatic output is generated, but the plot is rendered on the screen. If `getFig` is set to `True` then the matplotlib object is returned, rather than rendered on the screen.\r\n`show_single_uverskyPlot(hydropathy, mean_net_charge, label='', title='Uversky plot', legendOn=True, xLim=1, yLim=1, fontSize=10, getFig=False)` | `hydropathy` is the sequence's 0-1 normalized hydropathy, while `mean_net_charge` is the the absolute value of the sequence's mean net charge. `label`, if included, should be a string with which the sequence on the plot is labelled. `title`, if provided, sets the plot title. `legendOn` defines if the 5-region legend for the phase diagram plot is included. `xLim` and `yLim` define the max values for the X and Y axes. `fontSize` defines the size of the label font. `getFig` defines if a matplotlib object is returned instead of being rendered. | No programatic output is generated, but the plot is rendered on the screen. If `getFig` is set to `True` then the matplotlib object is returned, rather than rendered on the screen.\r\n`save_single_phasePlot(fp, fn, filename, label='', title='Diagram of states', legendOn=True, xLim=1, yLim=1, fontSize=10)` | `fp` is the fraction of positive residues in a sequence, `fn` is the fraction of negative residues in a sequence. `filename` is the name of the file to save the plot as (`.png` is appended). `label`, if included, should be a string with which the sequence on the plot is labelled. `title`, if provided, sets the plot title. `legendOn` defines if the 5-region legend for the phase diagram plot is included. `xLim` and `yLim` define the max values for the X and Y axes. `fontSize` defines the size of the label font. | No programatic output is generated, but the plot is constructed and saved at the `filename` location. \r\n`save_single_uverskyPlot(hydropathy, mean_net_charge, filename, label='', title='Uversky plot', legendOn=True, xLim=1, yLim=1, fontSize=10)` | `hydropathy` is the sequence's 0-1 normalized hydropathy, while `mean_net_charge` is the the absolute value of the sequence's mean net charge. `filename` is the name of the file to save the plot as (`.png` is appended). `label`, if included, should be a string with which the sequence on the plot is labelled. `title`, if provided, sets the plot title. `legendOn` defines if the 5-region legend for the phase diagram plot is included. `xLim` and `yLim` define the max values for the X and Y axes. `fontSize` defines the size of the label font. | No programatic output is generated, but the plot is constructed and saved at the `filename` location.\r\n\r\nIf you wish to plot a single sequence's Das-Pappu diagram of states plot or Uversky plot from a `SequenceParameters` object we suggest using the appropriate `SequenceParameters` functions (e.g.  `.show_uverskyDiagram()`, `.show_phaseDiagram()`)\r\n\r\n### `*_multiple*_` functions\r\n\r\nFor the `multiple` plotting functions, we pass in a list of values or objects corresponding to the multiple sequences of interest. \r\n\r\nThere are two types of multiple plots\r\n\r\n**1)** Those which you pass two lists of the actual values of interest, where the lists represent parallel lists, where the position in each list corresponds to a specific sequence.\r\n**2)** Those which you pass a list of `SequenceParameters` objects to, meaning you only pass it a single list\r\n\r\n\r\nThe `show_*` functions render a plot on the screen in front of you through `matplotlib`. These are useful for directly interacting with sequences and examining how specific sequence might behave. You can also directly access the matplotlib object through the `getFig` argument.\r\n\r\nThe `save_*` functions save a plot to the designated file name.\r\n\r\nFunction name | Input Arguments | Discussion\r\n:---: | :---: | :---:\r\n`show_multiple_phasePlot(fp_list, fn_list, label_list=[\"\"], title=\"Diagram of states\", legendOn=True, xLim=1, yLim=1, fontSize=10, getFig=False)`  | `fp_list` and `fn_list` are lists of the positive fraction and negative fraction of sequences, where the list position in each of these two 'parallel' lists corresponds to the same sequence. That is to say, if you were looking at 5 sequences, `fp_list` and `fn_list` would both be of length 5, and `fp_list[2]` and `fn_list[2]` would represent the fraction position and fraction negative of your third sequence, respectively. `label_list`, if included, should be a list of strings corresponding to the length of `fn_list` and `fp_list`, and includes names for each sequence on the plot. `title`, if provided, sets the plot title. `legendOn` defines if the 5-region legend for the phase diagram plot is included. `xLim` and `yLim` define the max values for the X and Y axes. `fontSize` defines the size of the label font. If `getFig` is set to `True` then the matplotlib object is returned, rather than rendered on the screen. | No programatic output is generated, but the plot is rendered to the screen.  \r\n`show_multiple_phasePlot2(SeqParam_list, label_list=[\"\"], title='Diagram of states', legendOn=True, xLim=1, yLim=1, fontSize=10, getFig=False)` | All arguments are the same as above, except now instead of explicit fraction of positive and fraction of negative lists, we have a single list containing `SequenceParameters` objects, from which these properties are derived.  | No programatic output is generated, but the plot is rendered to the screen.\r\n`show_multiple_uverskyPlot(hydropathy_list, mean_net_charge_list, label_list=[\"\"], title='Uversky plot', legendOn=True, xLim=1, yLim=1, fontSize=10, getFig=False)` | `hydropathy_list` and `mean_net_charge_list` are lists of the 0-1 normalized hydropathy and the absolute mean net charge, where the list position in each of these two 'parallel' lists corresponds to the same sequence. `filename` is the name of the file to save the plot as (`.png` is appended). `label_list`, if included, should be a list of strings corresponding to the length of `fn_list` and `fp_list`, and includes names for each sequence on the plot. `title`, if provided, sets the plot title. `legendOn` defines if the 5-region legend for the phase diagram plot is included. `xLim` and `yLim` define the max values for the X and Y axes. `fontSize` defines the size of the label font. If `getFig` is set to `True` then the matplotlib object is returned, rather than rendered on the screen. | No programatic output is generated, but the plot is rendered to the screen. \r\n`show_multiple_uverskyPlot2(SeqParam_list, label_list=[\"\"], title='Uversky plot', legendOn=True, xLim=1, yLim=1, fontSize=10, getFig=False)` | All arguments are the same as above, except now instead of having an explicit hydropathy list and an explicit mean net charge list, we have a single list containing `SequenceParameters` objects, from which these properties are derived. | No programatic output is generated, but the plot is rendered to the screen. \r\n`save_multiple_phasePlot(fp_list, fn_list, filename, ?label_list=[\"\"], ?title=\"Diagram of states\", ?legendOn=True, ?xLim=1, ?yLim=1,?fontSize=10)`  | `fp_list` and `fn_list` are lists of the positive fraction and negative fraction of sequences, where the list position in each of these two 'parallel' lists corresponds to the same sequence. That is to say, if you were looking at 5 sequences, `fp_list` and `fn_list` would both be of length 5, and `fp_list[2]` and `fn_list[2]` would represent the fraction position and fraction negative of your third sequence, respectively. `filename` is the name of the file to save the plot as (`.png` is appended). `label_list`, if included, should be a list of strings corresponding to the length of `fn_list` and `fp_list`, and includes names for each sequence on the plot. `title`, if provided, sets the plot title. `legendOn` defines if the 5-region legend for the phase diagram plot is included. `xLim` and `yLim` define the maximum values for the fraction of negative and positive residues. `fontSize` defines the size of the label font. | No programatic output is generated, but the plot is constructed and saved at the `filename` location. \r\n`save_multiple_phasePlot2(SeqParam_list, filename, label_list=[\"\"], title='Diagram of states', legendOn=True, ?xLim=1, ?yLim=1,?fontSize=10)` | All arguments are the same as above, except now instead of explicit fraction of positive and fraction of negative lists, we have a single list containing `SequenceParameters` objects, from which these properties are derived.| No programatic output is generated, but the plot is constructed and saved at the `filename` location.\r\n`save_multiple_uverskyPlot(hydropathy_list, mean_net_charge_list, filename, label_list=[\"\"], title='Uversky plot', legendOn=True, xLim=1, yLim=1, fontSize=10`) | `hydropathy_list` and `mean_net_charge_list` are lists of the 0-1 normalized hydropathy and the absolute mean net charge, where the list position in each of these two 'parallel' lists corresponds to the same sequence. `filename` is the name of the file to save the plot as (`.png` is appended). `label_list`, if included, should be a list of strings corresponding to the length of `fn_list` and `fp_list`, and includes names for each sequence on the plot. `title`, if provided, sets the plot title. `legendOn` defines if the 5-region legend for the phase diagram plot is included. `xLim` and `yLim` define the maximum values for the fraction of negative and positive residues. `fontSize` defines the size of the label font.| No programatic output is generated, but the plot is constructed and saved at the `filename` location. \r\n`save_multiple_uverskyPlot2(SeqParam_list, filename, label_list=[\"\"], title='Uversky plot', legendOn=True, xLim=1, yLim=1, fontSize=10)` | All arguments are the same as above, except now instead of having an explicit hydropathy list and an explicit mean net charge list, we have a single list containing `SequenceParameters` objects, from which these properties are derived. | No programatic output is generated, but the plot is constructed and saved at the `filename` location. \r\n\r\n\r\n# `localcider` exceptions\r\n\r\nIf you're into exception handling, localcider has a set of defined exceptions (all of which inherits from the `Exception` base class) which can be access by importing localcider - i.e.\r\n\r\n    import localcider\r\n    \r\n    localcider.SequenceFileParserException\r\n    localcider.SequenceException\r\n    localcider.ResTableException\r\n    localcider.PlottingException\r\n    \r\nThere are a couple more but these relate to functionality not yet available in version 0.1.9\r\n\r\n# Tutorials \r\n\r\n\r\n## 1) Calculate a bunch of parameters associated with a sequence I found on the internet\r\n\r\n    from localcider.sequenceParameters import SequenceParameters\r\n    \r\n    # define my internet sequence and create a new SequenceParameters object with it\r\n    internetSequence=\"VAQKTVEGAGSIAAATGFVKKDQLGKNEEGAPQEGILEDMPVDP\"\r\n    object=SequenceParameters(internetSequencexs)\r\n    \r\n    \r\n    # Let's get some parameters!\r\n    object.get_kappa()                       # 0.1960\r\n    \r\n    object.get_fraction_negative()           # 0.1818\r\n    \r\n    object.get_fraction_positive()           # 0.0909\r\n    \r\n    object.get_fraction_disorder_promoting() # 0.75\r\n    \r\n    object.get_amino_acid_fractions()        # {'A': 0.136,\r\n                                             #  'C': 0.0,\r\n                                             #  'D': 0.0682,\r\n                                             #  'E': 0.1136,\r\n                                             #  'F': 0.0227,\r\n                                             #  'G': 0.1364,\r\n                                             #  'H': 0.0,\r\n                                             #  'I': 0.0455,\r\n                                             #  'K': 0.0909,\r\n                                             #  'L': 0.0455,\r\n                                             #  'M': 0.0227,\r\n                                             #  'N': 0.0227,\r\n                                             #  'P': 0.0682,\r\n                                             #  'Q': 0.0682,\r\n                                             #  'R': 0.0,\r\n                                             #  'S': 0.0227,\r\n                                             #  'T': 0.0455,\r\n                                             #  'V': 0.0909,\r\n                                             #  'W': 0.0,\r\n                                             #  'Y': 0.0}\r\n\r\n\r\n##### 2) Get a list of kappa values for a directory of `fasta` files.\r\n\r\n`fasta` files are defined as having the following structure\r\n\r\n\r\n    > Header, preceded by a '>' character\r\n    SEQUENCESEQUENCESEQUENCESEQUENCESEQUENCESEQUENCE\r\n    SEQUENCESEQUENCESEQUENCESEQUENCESEQUENCESEQUENCE\r\n    SEQUENCESEQUENCESEQUENCESEQUENCESEQUENCESEQUENCE\r\n    \r\nLet's imagine we have a directory with 10 fasta files (`seq0.fasta`, `seq1.fasta`, ..., `seq9.fasta`). The following script will calculate the kappa of all such sequences\r\n\r\n    # import a few things...\r\n    import os\r\n    from localcider.sequenceParameters import SequenceParameters\r\n    \r\n    # filelist is now a list of each file in the current directory\r\n    filelist = os.listdir(\".\")\r\n    \r\n    # create an empty list \r\n    list_of_SeqObjs = []\r\n    \r\n    # populate that list with SequenceParameters objects, which we construct from the\r\n    # sequence found in each file\r\n    for file in filelist:\r\n       list_of_SeqObjs.append(SequenceParameters(sequenceFile=file))\r\n\r\n\t# for each \r\n\tfor obj in list_of_SeqObjs:\r\n\t   print obj.get_kappa()\r\n\t   \r\nUh oh! One of our sequence files has an amino acid \"X\" in it - this isn't a canonical amino acid, so triggers a `SequenceFileParserException`. We actually just want to skip any such files, so we change the code above slightly. Specifically, let's change the for-loop that loops over each file;\r\n\r\n    # import a few things...\r\n    import os\r\n    from localcider.sequenceParameters import SequenceParameters\r\n    \r\n    ## NOTE - we now import the whole localcider module to give us access\r\n    ## to the exception classes\r\n    import localcider\r\n    \r\n    # get a list of all files in the current directory\r\n    filelist = os.listdir(\".\")\r\n    \r\n    # create an empty list \r\n    list_of_SeqObjs = []\r\n    \r\n    # populate that list with sequenceParameters objects, which we construct from the\r\n    # sequence found in each file\r\n    for file in filelist:\r\n       list_of_SeqObjs.append(SequenceParameters(sequenceFile=file))\r\n       \r\n       \r\n    # populate that list with SequenceParameters objects, which we construct from the\r\n    # sequence found in each file\r\n    for file in filelist:\r\n       try:\r\n\t      list_of_SeqObjs.append(SequenceParameters(sequenceFile=file))\r\n\t   except localcider.SequenceFileParserException:\r\n\t      # if we encounter a file parsing error just skip that sequence\r\n\t      continue\r\n\r\n\r\n## Example 3 - plotting two sequence on a single Das-Pappu phase diagram\r\n\r\n\t# import the plots module\r\n    from localcider import plots\r\n    \r\n    # import the SequenceParameters class from the sequenceParameters class\r\n    from localcider.sequenceParameters import SequenceParameters    \r\n    \r\n    # create two SequenceParameters objects\r\n    SynWT=SequenceParameters(\"MDVFMKGLSKAKEGVVAAAEKTKQGVAEAA\")\r\n    SynMut=SequenceParameters(\"MDVFMKGLSKAKEGEEKKAEKTKQGVAEAA\")\r\n    \r\n    \r\n    # showing with sequence labels\r\n    plots.show_multiple_phasePlot2([SynWT, SynMut],label_list=['WT','MUT'])\r\n    \r\n    # saving without\r\n    plots.save_multiple_uverskyPlot2([SynWT, SynMut], 'example', label_list=['WT','MUT'])\r\n\r\n\r\n## FAQ\r\n\r\n1. **I get a kappa value greater than 1?!**\r\n\r\nkappa is a ratio of your sequence's delta over the maximium possible value for a sequence of that composition. The original mechanism for computing what the maximum delta value is was using Monte Carlo simulations, but this is *extremely* computationally expensive. To avoid this we have developed a new deterministic algorithm that uses a number of rule-based heuristics. During early testing of these heuristics there were examples of kappa values being greater than 1, which indicates that these heuristics have failed. As of Fall 2015 we have run many millions of disordered sequences without encountering sequences with a kappa > 1. However, should you encounter a sequence with a kappa value greater than 1 PLEASE email the sequence to me, as it represents a very rare edge case that we haven't encountered in our testing procedures.\r\n\r\n2. **I want to run localCIDER on my cluster but it has not graphical frontend and I can't get matplotlib to work**\r\n\r\nThere is a plan to release a higher performance version of localCIDER which carries out the core functionality using C++. However, that's a way off, so for now a quick hack is to do the following;\r\n\r\n    * Download the sourcecode and unpack - this will be a local package, and means you don't have to instal localCIDER globally\r\n    * Move your local package to where you want to carry out the analysis\r\n    * Edit localcider/backend/plotting.py and comment out the two import lines which reference matplotlib\r\n    * Run your analysis\r\n\r\nIf you call any functions which depend on `matplotlib` this will obviously fail, but if not it'll work just fine.\r\n\r\n# Epilog\r\n\r\n## Feature request\r\nWe'd like localCIDER to be the single-software solution for sequence analysis. To this end, if you have analysis routines you would like to be incorporated used please contact us about adding these into localCIDER. If you can provide us with Python code for performing the analysis in question, we can almost guarentee incorporation into the next version of localCIDER. \r\n\r\n## About\r\nlocalCIDER was developed in the Pappu lab by Alex Holehouse, with additional code by James Ahad and Mary Richardson. Many of the early ideas were pioneered by [Dr. Rahul Das](https://sites.google.com/site/rahulkdas82/home). \r\n\r\nWe believe scientific software should be held to same (or higher) software standards as general commercial and open source projects. To this end we use Git for version control, employ standard conventions for versioning, run an ever-expanding set of unit tests, and try to ensure all code is well structured and well documented. The source code is fully open and [can be viewed here](https://github.com/Pappulab/localCIDER).\r\n\r\n\r\n## References\r\n\r\n**[1]** Campen, A. et al. TOP-IDP-scale: a new amino acid scale measuring propensity for intrinsic disorder. Protein Pept. Lett. 15, 956963 (2008).\r\n\r\n**[2]** Das, R. K. & Pappu, R. V. Conformations of intrinsically disordered proteins are influenced by linear sequence distributions of oppositely charged residues. Proc. Natl. Acad. Sci. U. S. A. 110, 1339213397 (2013).\r\n\r\n**[3]** Kyte, J. & Doolittle, R. F. A simple method for displaying the hydropathic character of a protein. J. Mol. Biol. 157, 105132 (1982).\r\n\r\n**[4]** Uversky, V. N. Natively unfolded proteins: a point where biology waits for physics. Protein Sci. 11, 739756 (2002).\r\n\r\n**[5]** Mao, A. H., Crick, S. L., Vitalis, A., Chicoine, C. L. & Pappu, R. V. Net charge per residue modulates conformational ensembles of intrinsically disordered proteins. Proc. Natl. Acad. Sci. U. S. A. 107, 81838188 (2010).\r\n\r\n**[6]** Elam WA, Schrank TP, Campagnolo AJ, Hilser VJ. Evolutionary conservation of the polyproline II conformation surrounding intrinsically disordered phosphorylation sites. Protein Sci. 2013; 22: 405- 417. doi: 10.1002/pro.2217 PMID: 23341186\r\n\r\n**[7]** Tomasso, M. E., Tarver, M. J., Devarajan, D. & Whitten, S. T. Hydrodynamic Radii of Intrinsically Disordered Proteins Determined from Experimental Polyproline II Propensities. PLoS Comput. Biol. 12, e1004686 (2016).\r\n\r\n**[8]** Wootton, J. C., & Federhen, S. (1993). Statistics of local complexity in amino acid sequences and sequence databases. Computers & Chemistry, 17(2), 149-163.\r\n\r\n**[9]** Troyanskaya, O. G., Arbell, O., Koren, Y., Landau, G. M., & Bolshoy, A. (2002). Sequence complexity profiles of prokaryotic genomic sequences: a fast algorithm for calculating linguistic complexity. Bioinformatics , 18(5), 679 - 688.\r\n\r\n**[10]** Lempel, A.& Ziv, J. (1976). On the complexity of finite sequence. IEEE Trans. Inf. Theory, vol. IT-22, no. 1, 75-81.\r\n\r\n**[11]** Murphy, L. R., Wallqvist, A., & Levy, R. M. (2000). Simplified amino acid alphabets for protein fold recognition and implications for folding. Protein Engineering, 13(3), 149-152.\r\n\r\n\r\n## Thanks\r\nMany people have been involved in this project. We'll try and include an up-to-date list here;\r\n\r\n* Paul Nobrega (University of Massachusetts) for bug reports and the Windows installation instructions\r\n* Davide Mercadante (Heidelberger Institut fur Theoretische Studien) for bug reports and code development to improve plotting customization\r\n* Katra Kolsek (Heidelberger Institut fur Theoretische Studien) for bug reports and code development to improve plotting customization\r\n* Alex Chin (Johns Hopkins University) for a crucial bug report\r\n* Thomas Pranzatelli (Washington University in St. Louis) for testing and bug reports\r\n* Carlos Hernndez (Stanford University) for Python 3 support and PEP8 compliance \r\n* Luke Wheeler (University of Oregon) for Python 3 testing\r\n \r\n\r\n## Update schedule\r\n\r\n* **version 0.1.0** - August 10th 2014: Initial release \r\n* **version 0.1.1** - August 14th 2014: Minor bug fixes, more tests, improved sequence parsing\r\n* **version 0.1.2** - October 1st 2014: More tests, fixed heuristic bugs in extreme kappa sequences, significant improvement on plotting customization, cleaned up docs and code documentation\r\n* **version 0.1.3** - October 13th 2014: More tests, corrected a bug introduced in 0.1.2 for sequences with no neutral residues, corrected a bug in how titles/labels were assigned by default, improved how classification into the 5 regions is done, and explicitly allow for regions 4 (positive electrolytes) and 5 (negative electrolytes) rather than general polyelectrolytes\r\n* **version 0.1.4** - January 16th 2015: Corrected bug in the way KD hydrophobicity was calculated - alanine incorrectly set to 0\r\n* **version 0.1.7** - February 25th 2015: Bunch of additional updates and code readability improvements, as well as changing how NCPR/FCR plots are made (bar instead of line)\r\n* **version 0.1.8** - March 28th 2016: Major update with a number of additional features. All figures can now be generated as PDFs, sequence complexity analysis has been added, PPII propensity added, kappa-P added. Pleasantly, no bugs needed fixing, however!\r\n* **version 0.1.9** - September 31st 2016: Added local amino acid composition, general patterning parameter, and improved on plot formatting. \r\n\r\n",
  "google": "UA-53151639-1",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}